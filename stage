#!/usr/bin/env bash
set -euo pipefail

# constants
readonly CI_DIR="/srv/docker/ci_runner"
readonly BUILD_DIR="/srv/docker/ci_runner/builders"
readonly DEFAULT_STAGING_DIR="${HOME}/packages"
readonly DEFAULT_BUILDER="arch"

usage() {
  echo "Usage: stage <project_dir> [staging_dir] [update_type]" >&2
}

# args
if [[ $# -lt 2 || $# -gt 4 ]]; then
  usage
  exit 1
fi

readonly SOURCE_PATH="$1"
readonly UPDATE_TYPE="$2"
readonly STAGING_DIR="${3:-$DEFAULT_STAGING_DIR}"
readonly BUILDER="${4:-$DEFAULT_BUILDER}"

if [[ ! -d "$SOURCE_PATH" ]]; then
  echo "Source project directory not found: $SOURCE_PATH" >&2
  exit 1
fi

readonly PROJECT_NAME="$(basename -- "$SOURCE_PATH")"
readonly SRC_DIR="$CI_DIR/src"
readonly OUT_DIR="$CI_DIR/out"


echo "Updating main branch with new packages..."
git -C $STAGING_DIR checkout main
git -C $STAGING_DIR pull origin main

echo "Switching to staging branch..."
if git -C $STAGING_DIR rev-parse --verify --quiet refs/heads/staging; then
  git -C $STAGING_DIR checkout staging
else
  echo "Local staging branch does not exist. Creating it."
  git -C $STAGING_DIR checkout -b staging
fi

echo "Preparing stage..."
mkdir -p "$SRC_DIR" "$OUT_DIR" "$STAGING_DIR"
rm -rf -- "$SRC_DIR"/* || true
rm -rf -- "$OUT_DIR"/* || true

echo "Staging..."
cp -a -- "$SOURCE_PATH" "$SRC_DIR/"

# docker compose controls
compose_up() {
  docker-compose -f "$BUILD_DIR/$BUILDER-builder.yml" up --abort-on-container-exit # --exit-code-from builder
}

compose_down() {
  docker-compose -f "$BUILD_DIR/$BUILDER-builder.yml" down -v 
}
trap compose_down EXIT

# run builder
echo "Running builder..."
echo " $BUILDER..." >&2
if ! compose_up ; then
  echo "Failed to build project $PROJECT_NAME" >&2
  exit 1
fi
trap - EXIT
compose_down || true

echo "Successfully built $PROJECT_NAME."


# update metadata w/ stage.py
echo "Updating metadata..."
PY_OUTPUT=""
if ! PY_OUTPUT=$(/bin/python3 "$CI_DIR/stage.py" "$PROJECT_NAME" "$UPDATE_TYPE" 2>&1); then
  echo "$PY_OUTPUT" >&2
  echo "Failed to update $PROJECT_NAME metadata" >&2
  exit 1
fi

# stage.py prints an informational line and then the package name on the last line
readonly PKG_NAME="$(printf '%s' "$PY_OUTPUT" | tail -n 1)"


# arrange outputs
echo "Moving to stage..."
readonly PROJECT_OUT_DIR="$OUT_DIR/$PROJECT_NAME"
mkdir -p "$PROJECT_OUT_DIR"
readonly METADATA_FILE="$OUT_DIR/${PKG_NAME}_md.json"
if [[ -f "$METADATA_FILE" ]]; then
  mv -f -- "$METADATA_FILE" "$PROJECT_OUT_DIR/metadata.json"
fi

# Compress results
echo "Compressing..."
readonly TARBALL="$OUT_DIR/${PKG_NAME}.tar.gz"
(
  cd "$OUT_DIR" >/dev/null
  tar -czf "$TARBALL" "$PROJECT_NAME"
)

# sync to staging
echo "Syncing..."
if ! rsync -a --exclude '.git' -- "$TARBALL" "$STAGING_DIR/$PROJECT_NAME/"; then
  echo "rsync failed, attempting fallback copy" >&2
  mkdir -p "$STAGING_DIR/$PROJECT_NAME"
  if ! cp -a -- "$TARBALL" "$STAGING_DIR/$PROJECT_NAME/"; then
    echo "Failed to move files to staging directory" >&2
    exit 1
  fi
fi

# attempt to normalize ownership
if id -u 1000 >/dev/null 2>&1; then
  chown -R 1000:1000 "$STAGING_DIR" || true
fi

echo "Pushing to github repo..."

git -C $STAGING_DIR add .
git -C $STAGING_DIR commit -m "Staging $PROJECT_NAME"
git -C $STAGING_DIR push -f origin staging


echo "Successfully staged $PROJECT_NAME"
